:PROPERTIES:
:ID:       b9a1580b-5dbb-4e54-b3d7-6fa53c7008c2
:END:
#+title: ReTa und ReTaPrompt readme in Emacs Org Mode - Entwickler-Notizen

#+CAPTION: R10-Symbole
#+NAME:   fig:R10-Symbole
[[./symbole.png]]
** viele Programmier-Notizen aus altem Selfblog zusammen-gefasst :programmieren:dev:development:reta:features:bugs:csv:debugging:refactoring:@Programmieren:
:PROPERTIES:
:CLOSED: [2022-11-17T18:20]
:EXPORT_DATE: [2022-11-17T18:20]
:EXPORT_FILE_NAME: 2
:EXPORT_HUGO_WEIGHT: -2
:draft: false
:EXPORT_OPTIONS: toc:5.
:END:
*** 1. Feature Ideen
+ Dass man die Anzahl der Spalten bestimmt, anstelle die Breite pro Spalte, was nur geht wenn --spalte und --spalten nicht angegeben wird. Das auch als Kurzbefehl machen. sqrt(bytes spalte 1)/sqrt(textbytes_spalte_1)+sqrt(auch spalte 2)= Anteil der Spalte von 100% der gesamten Spaltenbreite.
+ Ein Feature wäre schon ganz nett, wenn man zumindestens wenigstens die Kurzbefehle im Prompt speichern kann und die Zahlenliste
+ Syntax highlighting
+ dinge bei zsh abschauen
+ schöneres UTF
+ csv diff und insert geht schnell zu programmieren.
Kann man ncurses einfach zu web konvertieren, ohne viel Aufwand oder wurde das nicht erfunden?
+  ReTa besser ausführlicher, detaillierter, dokumentieren und auf viele Bereiche und Teile gedanklich eingehen.
+  Option für nur temporäres Logging
nicht loggen, bei befehlen über Logging
+  Dass man Kurzbefehlen auch die ReTa-Programm-Argumente mitgeben kann: geht schon, nur fehlt autocomplete intellisense dafür
+ Wie programmiere ich, dass nachträgliches Resizen der CLI App geht?
+ --parameter=* könnte alle Unter-Parameter meinen, als Kommandozeilenargument.
+ Kurzform für Zeile und Spalte einführen, statt die langen Befehlsketten immer.
+ Die Spaltennummer direkt als Zahl wählen können.
+ Multiplikation aus 3 Faktoren, oder mehr, statt nur aus 2:
python print(str((1,*(2,3))))
(1, 2, 3)
Geht einfach und schnell zu programmieren durch Rekursion.
+ machen, dass alles Kurze mit Fragezeichen oder Minus oder nur Whitespace in RetaPrompt einfach nicht ausgegeben wird
+ Programmieren, dass man die Konsole beliebig resizen kann, und dass es dann immernoch die richtige Größe ermöglicht.
  + Teil A
    1. Sortierte Ausgabe
    2. Option begrenzter Auswahl von Zahlen.
    3. Intern die Zahlenkombi in eigene Datenstruktur packen, anstelle gleich in den String verwursten.
  + Teil B
    1. Parameteroption hinzufügen
    2. später in Readme, try catch fehlerausgabe und befehlliste für retaPrompt, oder ggf. etc., dazu bauen
    3. statt String Zahlenliste machen
    4. Zahlen vorher ordnen und dann hinzufügen
    5. nach Zahlen filtern durch diesen Programm-Parameter.
    6. 2. durchführen.
+ Um bessere Farben für die html zu finden, sollte ich einen screenshot davon machen und diesen mit gimp so bearbeiten, dass ich exakt eine Farbe in eine andere ändere. In Gimp kann ich viele Farben ausprobieren.
+ neues Farbschema: für html aber besser nur: primzahlen pro außen und pro innen und ggf. dessen vielfacher; Farbschema mit durch 3 teilbarem außerdem
*** 2. Bugs
+ Bei ReTaPrompt gibt es das Problem, dass Textvorschläge gemacht werden, bei denen das nicht richtig ist.
Es ist ja schön, wenn ich weiß, was ich tippen muss, aber ich darf das nicht so lassen.
Es reicht nicht, wenn ich ReTa nur so programmiere, dass es mir passt.
Es muss auch für manche DAUs funktionieren.
*** 3. ReTa content
+ Ich müsste mal die gebrochen-rationalen Gefühle probieren zu machen.
Das würde mir gut woanders weiterhelfen.
*** 4. Feature - Geschwindigkeit
+  Wo ist Verbesserung der Geschwindigkeit möglich:
+ bei der Ausgabe
+ Parallelisierung
+ dass nach neuer Eingabeaufforderung nicht alles neu gelesen werden muss
+ binäres Datenbank-Format, statt csv, besser über Pandas, das Numpy Datenstrukturen verwendet und für DBs ein binäres Format zur Verfügung hat
+ Ich bin sehr wohl sehr gut mit Rekursiver Programmierung vertraut. Ich hatte so etwas mehr als genug im Studium.

Sollte ich es irgendwann fertigstellen die Matritzen mit Numpy Matritzen ersetzt zu haben,
dann wäre der nächste Schritt die CLI Ausgaben der Tabellen auf Meta-Programmierung umzustellen.
Das wird ReTa sehr beschleunigen, weil nach Code-Analyse dort die hauptsächlichen Geschwindigkeitseinbußen zu finden sind.
Ich brauche also ein Programm, das Quelltext baut, der die Tabelle dann ausgeben soll. Das ist Meta-Programmierung.
Dieser Quelltext hat dann weniger Code und Bedingungsabfragen und ist weniger komplex.
Die bisherige Programmfunktion zur Ausgabe ist einziges Chaos. Aber ich verstehe sie.

Danach erst macht es Sinn alles zu Parallelisieren.
Ich sehe nicht ein, etwas zu parallelisieren, das selbst noch deutlich ordentlicher werden könnte.
Das wäre sonst umständlich und mehr Mehrarbeit. Alles muss in der richtigen Reihenfolge programmiert werden, sodass man sich nicht zu viel Mehrarbeit aufhalst.

Das alles hat aber unterster niedrigste Priorität, denn dabei geht es nur um Geschwindigkeitsvorteile und die sind momentan unwichtig. Aber irgendwann müsste das schon noch gemacht werden. Was solls. ReTa soll doch nur so eine Art Proof-of-Work sein. Es soll voll alles können, aber richtig ordentlich darf das dann jemand anderes machen, mit mehr und besserer Dokumentation: Einfach Arbeitsteilung. Ich mache das Ernste und jemand anders ist der Codemonkey, der End-User-Programme baut, die bestenfalls für den DAU optimal sind.

Der darf dann der Super-Programmierer sein, der den besten Code schreibt, den jeder lesen kann und der hochoptimiert ist und super refactored, mit tollen Features, eben für Endanwender, mit Clean-Code, Parallelisierung, mit wenig notwendiger Dokumentation, weil alles für Enduser optimiert und mit dennoch mit viel ausreichender Dokumentation. Dafür darf der Codemonkey gerne die komplexeste komplizierteste Programmiersprache verwenden, denn er braucht das und ihm gefällt das. Der darf gerne auf einfachere Programmiersprachen herabschauen. Ich habe jedenfalls nur begrenzte Lebenszeit.

Deshalb programmiere ich ReTa als Proof-of-Work, als ein Programm, das dennoch aber alles können soll und gut können soll. Es soll aber kein Programmiertechnisches Meisterwerk sein, weil ich wichtigere Prioritäten habe, als mich um super Code zu kümmern. Bei mir muss es um Inhalte gehen. Auf der einen Seite programmiere ich ReTa aber auch viel für mich und für meine Anforderungen, wenn ich es gebrauchen muss.

Was ansonsten noch für deutlich fernere Zukunft noch für RetaPrompt gebrauchbar ist, wäre Skriptingfähigkeit. Dann kann man Skripten, mit einer Schleife oder Rekursion, welche Zeilennummern man möchte und was einem sonst noch so einfällt. Dann kann man Variablen verwenden und wiederverwenden, usw.

Irgendjemand kann sich vielleicht noch eine eigene SQL-ähnliche Syntax einfallen lassen, wenn es darum gehen soll, diese Tabellen wie SQL Tabellen zu verschachteln.
*** 5. Feature: Mathe
+ z.B. ggT & kgV
Vielfacher einer Zahl für einen Bereich
Distanzen einer Zahl zu einem Bereich
Dabei unterscheiden zwischen pro-außen und pro-innen Primzahlen

Überlegen, ob sich rp etwas merken soll und was das sein sollte.
Vielleicht alles zu vorigem Kommando, sodass man einen Modus wählen könnte, in welchem man Teile abwählen und anwählen kann.
Befehl-Teile in Variablen speichern und diese Variablen abrufen.
Beliebige Substitutionen

ascii art und emoticons in cli
scriptingfähigkeit, statt nur den python befehl
wozu? unnötig! oder?

Verzeichnisbaum von den Reta-Paramtern durchwandern, so wie man Ordner in Dateisystemen durchwandern kann.
Und den Baum der anderen Hierarchieordnung der Grundstrukuren, anders als die der ReTa-Parameter selbst.

mit einem Zeichen wie "+" könnte ich vorwärts scrollen als neue Befehlseingabe für weitere Tabellenansichten.

Bei größeren Tabellenansichten wäre eine Schnellscrollfunktion in 2 Richtungen nicht schlecht für die CLI.

EDIT:
Nutzen von Skriptingfähigkeit:
z.B. beliebig geskriptete Zeilennummern, z.B.: alle modulo 24 + pro außen primzahlen, alle primzahlen auf dem primzahlkreuz über der 7.

EDIT:
In ReTA-Prompt anfangs texten, dass gerade vi-mode oder emacs-mode aktiv ist.
*** 6. Überlegungen
+ Meine Stabilität Policy ist eine Schande
       https://doc.pypy.org/en/latest/cpython_differences.html
  + endlich mal unit tests machen
  + große funktionen in mehrere kleinere verwandeln.
  + gute lib für unit tests nehmen, pytest soll gut sein
  + bis zu Punkten mit exit() gehen und so eine volle Ausgabe davon machen
  + diese Ausgabe für pypy3 und python3 vergleichen
  + sortieren, stufenweise weiter machen

+ Vielleicht könnte oder sollte ich aspektorientierte Programmierung für die Textausgabe von ReTa verwenden, sofern Python das kann, weil die Klassen-Methode davon ein einziges wildes Durcheinander ist, aber ich bin mir unschlüssig, wie ich das besser mache, ohne zu viele Redundanzen zu erzeugen. Aber es funktioniert doch alles bestens. Wieso sollte ich also Refactoren?
+ Permanentes Erweitern der Matrix ist doch Perfomance-Unsinn. Ich sollte die Matrix von Anfang an in der richtigen Größe haben.

Außerdem sollte ich mir richtig lange Zeit nehmen, das überhaupt einzuprogrammieren, wegen der Zeit und weil das nicht eilt und weil es eigentlich auch nicht so super wichtig ist.

Aber meine Tabelle wird immer größer und es wird dadurch langsamer.

Ich mache es mir am Einfachsten, wenn ich die Matrix richtig groß mache.
Ich kann sie schon als reine Numpy Matrix mit fester Stringgröße einstellen, weil diese dann ja wieder einfach mit Panda verwendbar ist. Das sollte ich aber austesten, auch wenn das sicher wäre.

Ich sollte das in großen Zeitabständen programmieren, weil die Priorität mittelmäßig ist.

Same typed matrix of same sized strings = faster

Ähnlich wie strArr = numpy.empty(10, dtype='s256')
+ Es gäbe da einige Methoden ReTa zu beschleunigen.
Ich denke, ich werde keine davon umsetzen, auch wenn es teilweise alles sehr langsam geworden ist.
Am besten wäre es, wenn ich alles neu in Rust schreiben würde und alle Designfehler nicht mehr machen würde und von vornherein Parallelisierung nur als Möglichkeit einbeziehe, es doch nicht objektorientiert, sondern prozedural zu programmieren.
Das ist jedoch die Zeit nicht wert. Mir fehlt dazu die Lebenszeit.
Ich will doch am Ende Zeit sparen, aber wenn ich das alles neu programmieren würde, hätte ich einen viel größeren Zeitverlust.

Man soll angeblich Python deutlich beschleunigen können, wenn man sehr geschickt und schlau ist.
Es gäbe da einiges, das ich tun könnte, um es bei Python zu belassen und dennoch ausreichend zu beschleunigen:
+ Listen und Matritzen von Numpy verwenden
+ Pandas verwenden und dadurch auf manche meiner Algorithmen verzichten, und Pandas nutzt bereits sowieso Numpy Matritzen
+ Parallelisierung durch mehr Prozesse der gleichen ausführbaren Datei

Aber auch dazu fehlt mir die Zeit und das alles würde mir mehr Zeit kosten, als dass es mir insgesamt einen Zeitvorteil bringt.

Ansonsten müsste mein ReTa Programm sowieso grundlegend refactored werden, und entschlackt werden und so umdesigned werden, dass es das Gleiche tut, aber das programmiertechnische Design einfacher ist. Z.B. sollte ich die Klassen und Objekte wieder zu Prozeduren machen, dass alles prozedural, statt objektorientiert, funktioniert.

Und dann hätte ich bereits schon längst überhaupt Unit-Test-Prozeduren schreiben sollen, was ich nie tat.

Dass ich ReTa nun in einem halbwegs schlechten Zustand hinterlassen muss, schmerzt mich ein wenig. Es tut aber eigentlich, was es soll. Und das ist das Wichtigste.
Für mich als Programmierer ist es aber unbefriedigend, wenn ich ein Programm gut verbessern kann, aber ich mich selbst davon abhalten muss, aus Vernunft. Aus Vernunft muss ich etwas hinterlassen, das ich perfekter hätte machen können. Das macht keinen Spaß.

Eigentlich hatte ich die Hoffnung eingeplant, irgendwann Programmierer bezahlen zu können, die dann die Arbeit erledigen, für die man mich nicht braucht, sondern die sich nur um Technisches kümmern. Wenn ich viel phantasieren und träumen würde, dann passiert das vielleicht in meiner Phantasie, aber die Realität ist davon besonders weit entfernt; heute noch entfernter, als vor Jahren.
+  statt csv und normale Matritzen:

pandas binärformat, das csv ersetzt, welches für matrizen numpy verwendet.
Dann kann ich auch gleich pandas matrix funktionen verwenden, die wie sql funktionieren.
Ich hätte das gleich so machen sollen, aber ich konnte nicht wissen, wie riesig reta wird.

Sollte ich das umsetzen wollen, dann sollte ich unbedingt einen neuen eigenen Branch dafür anlegen, komme was wolle.

*** 7. Refacturing
+ Aus Objektorientiertem Prozedurales machen, es sei denn es ist besser wie es war in wenigen Fällen.
+ Vorher planen, viel Durchdenken.
+ Oder statische Klassen, statt Instanzen verwenden.
+ Aufhören damit, weg machen: mehrfache Art gleichzeitig Variablen zu übergeben und zu referenzieren: Das ist liederlich, unordentlich.
+ Vielleicht mal besser doch Clean Code umsetzen, obwohl mir das den Spaß wegnimmt.
+ aufbesser:
  + Antipattern
  + Code Smells
  + Clean Code umsetzen
  + Entwurfsmuster umsetzen
  + Lesbarkeit verbessern
  + Code und Funktionen ausführlich kommentieren
+ Unit-Tests einbauen
+ Die gleiche Variable nicht auf dutzende Arten mehrfach vorhanden zu haben
